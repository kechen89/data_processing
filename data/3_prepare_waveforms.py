# 3_prepare_waveforms.py
# Loops over events and prepares waveforms
# Uses 'catalog_ncss.xml'
#   QuakeML file generated by 1_event_catalog_waveform_search.py
# Specifically it does the following:
#   instrument correction to ground velocity in m/s
#   rotate to ZNE and ZRT
#   write sw4 station file
#   plot map of event locations (NCSS, DD), moment tensor, stations

from os import path, chdir, getcwd, makedirs
from sys import exit
import obspy
import ast
import glob
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
from obspy.imaging.beachball import beach

#######################################
# Set parameters here
# netchan is a list of network-channel type strings, e.g. 'BK.BH'
# This must be the same as used in previous script
#netchans = [ 'BK.BH', 'BK.HN' ]
#netchans = [ 'BK.BH', 'BK.HN', 'BK.BN', 'NC.HN', 'NP.HN', 'CE.HN', ]
#netchans = [ 'BK.BH', 'BK.HH', 'BK.HN', 'BK.BL', 'BK.CN', 'NC.HN', 'CE.HN', 'NP.HN'  ]

#netchans = [ 'BK.BH', 'BK.HN']
#netchans = [ 'BK.BH' ]

netchans = ['BK.BH'] #, 'BK.HN', 'BK.BN', 'BK.BL', 'BK.CL', 'NC.HN', 'NP.HN', 'CE.HN']

#pre_filt = (0.0125, 0.02, 10.0, 12.0)
pre_filt = (0.03, 0.05, 10.0, 12.0)
output_ground_motion = "VEL"
# Origin time, from previous script
t0 = 5.0
# Time windows around DD origin 
t1 = t0
t2 = 60.
# Filter for record section plot
f1 = 0.1
f2 = 1.0

cat_ncss = obspy.read_events('catalog_ncss.xml')

# Loop over events in catalog
for event in cat_ncss.events:   
    event_id = str(event.resource_id).split('/')[-1]
    print()
    print('#################')
    print('Event_id: ', event_id)
    
    try: 
        path.exists(event_id)
    except:
        print('Directory for this event_id does not exist: ', event_id)
        exit()
    chdir(event_id)
    print('Current directory: ', getcwd())
    event.write(event_id+".xml", format="QUAKEML") 
    if not path.exists(output_ground_motion):
        makedirs(output_ground_motion)
    
    # Read ncssorigin
    with open(event_id+'.ncssorigin', 'r') as f_dd:
        ncss_origin = ast.literal_eval(f_dd.readline())
    otime = obspy.UTCDateTime(ncss_origin['otime'])
    print('ncss_origin: ', ncss_origin, ' otime: ', otime)
    # Read ddorigin
    with open(event_id+'.ddorigin', 'r') as f_dd:
        dd_origin = ast.literal_eval(f_dd.readline())
    otime = obspy.UTCDateTime(dd_origin['otime'])
    print('dd_origin: ', dd_origin, ' otime: ', otime)
    
    # Assign standard NCSS origin
#    evla = ncss_origin['latitude']
#    evlo = ncss_origin['longitude']
#    evdp = ncss_origin['depth']/1000
    
    # Assign double-difference DD  origin
    evla = dd_origin['latitude']
    evlo = dd_origin['longitude']
    evdp = dd_origin['depth']/1000
                        
    # Now move to 'RAW' directory, loop over netchans
    chdir('RAW')
    print('cwd: ', getcwd())
    station_list = []
    for netchan in netchans:
        chdir(netchan)
        net = netchan.split('.')[0]
        chan = netchan.split('.')[1]
        print('event_id: ', event_id, ' netchan: ', netchan)
        # In event_id/RAW/netchan directory
        if glob.glob('*mseed') != []:
            if not path.isdir('../../VEL/'+netchan):
                makedirs('../../VEL/'+netchan)
            st = obspy.read('*.mseed')
            print(st)
            net_sta_list = sorted(set([ net+'.'+tr.stats.station for tr in st ]))
            for net_sta in net_sta_list:
                sta = net_sta.split('.')[1]
                print ('net_sta: ', net_sta)
                st = obspy.read(net_sta+'.*.mseed')
                st_gcp = obspy.Stream()
                st_gcp_hor = obspy.Stream()
                print('cwd: ', getcwd())
                inv = obspy.read_inventory('_station_xml/'+net+'.'+sta+'.xml')
                #st.taper(type='hann', max_percentage=0.05)
                st.remove_response(inventory=inv, pre_filt=pre_filt, output=output_ground_motion)
                # Check if we have 3-components
                comps = [ tr.stats.channel[-1] for tr in st ]
                print(event_id, netchan, sta, comps)
                if comps == ['E', 'N', 'Z']:
                    for tr in st:
                        seed_id = net+'.'+tr.stats.station+'.'+tr.stats.location+'.'+tr.stats.channel
                        print('seed_id: ', seed_id)
                        coords = inv.get_coordinates(seed_id)
                        seed_id = net+'.'+tr.stats.station+'.'+tr.stats.location+'.'+tr.stats.channel
                        comp = tr.stats.channel[-1]
                        tr_output = tr.slice(otime - t1, otime + t2)
                        sac = obspy.io.sac.sactrace.SACTrace.from_obspy_trace(tr_output)
                        sac.stla = coords['latitude']
                        sac.stlo = coords['longitude']
                        sac.stel = coords['elevation']
                        sac.stdp = coords['local_depth']
                        sta_inv = inv[0]
                        chan_inv = sta_inv.select(channel=tr.stats.channel)
                        sac.cmpaz = chan_inv[0].channels[0].azimuth
                        sac.cmpinc = 90.+chan_inv[0].channels[0].dip
                        sac.kcmpnm = chan+comp
                        sac.evla = evla
                        sac.evlo = evlo
                        sac.evdp = evdp
                        sac.lcalda = True
                        sac.o = t0
                        filename = net+'.'+tr.stats.station+'.'+chan+comp+'.sac'
                        sac.write('../../'+output_ground_motion+'/'+netchan+'/'+filename)
                    epi_dist, az, baz = obspy.geodetics.gps2dist_azimuth(sac.evla, sac.evlo, sac.stla, sac.stlo)
                    print('epi_dist, az, baz', epi_dist, az, baz)
                    # Check that the length of each trace is equal
#                    print('starttimes: ', [ tr.stats.starttime for tr in st ])
#                    print('endtimes: ', [ tr.stats.endtime for tr in st ])
#                    print('npts: ', [ tr.stats.npts for tr in st ])
                    st.trim(starttime=max([ tr.stats.starttime for tr in st ]), endtime=min([ tr.stats.endtime for tr in st ]))
                    st_gcp_hor = st.rotate(method='NE->RT', back_azimuth=baz)[0:2]
                    
                if comps == ['1', '2', '3']:
                    for tr in st:
                        seed_id = net+'.'+tr.stats.station+'.'+tr.stats.location+'.'+tr.stats.channel
                        print('seed_id: ', seed_id)
                        coords = inv.get_coordinates(seed_id)
                        seed_id = net+'.'+tr.stats.station+'.'+tr.stats.location+'.'+tr.stats.channel
                        comp = tr.stats.channel[-1]
                        tr_output = tr.slice(otime - t1, otime + t2)
                        sac = obspy.io.sac.sactrace.SACTrace.from_obspy_trace(tr_output)
                        sac.stla = coords['latitude']
                        sac.stlo = coords['longitude']
                        sac.stel = coords['elevation']
                        sac.stdp = coords['local_depth']
                        sta_inv = inv[0]
                        chan_inv = sta_inv.select(channel=tr.stats.channel)
                        sac.cmpaz = chan_inv[0].channels[0].azimuth
                        sac.cmpinc = 90.+chan_inv[0].channels[0].dip
                        sac.kcmpnm = chan+comp
                        sac.evla = evla
                        sac.evlo = evlo
                        sac.evdp = evdp
                        sac.lcalda = True
                        sac.o = t0
                        filename = net+'.'+tr.stats.station+'.'+chan+comp+'.sac'
                        sac.write('../../'+output_ground_motion+'/'+netchan+'/'+filename)
                    epi_dist, az, baz = obspy.geodetics.gps2dist_azimuth(sac.evla, sac.evlo, sac.stla, sac.stlo)
                    print('epi_dist, az, baz', epi_dist, az, baz)
                    st.trim(starttime=max([ tr.stats.starttime for tr in st ]), endtime=min([ tr.stats.endtime for tr in st ]))
                    dataz , datan, datae = obspy.signal.rotate.rotate2zne(st[0], inv[0][0][0].azimuth, inv[0][0][0].dip, st[1], inv[0][0][1].azimuth, inv[0][0][1].dip , st[2], inv[0][0][2].azimuth, inv[0][0][2].dip)
                    trz = st[0]
                    trz.data = dataz
                    comp = 'Z'
                    trz_output = trz.slice(otime - t1, otime + t2)
                    sac = obspy.io.sac.sactrace.SACTrace.from_obspy_trace(trz_output)
                    sac.stla = coords['latitude']
                    sac.stlo = coords['longitude']
                    sac.stel = coords['elevation']
                    sac.stdp = coords['local_depth']                    
                    sac.cmpaz = 0.
                    sac.cmpinc = 0.
                    sac.kcmpnm = chan+comp
                    sac.evla = evla
                    sac.evlo = evlo
                    sac.evdp = evdp
                    sac.lcalda = True
                    sac.o = t0
                    filename = net+'.'+sta+'.'+chan+comp+'.sac'
                    sac.write('../../'+output_ground_motion+'/'+netchan+'/'+filename)
                        
                    trn = st[1]
                    trn.data = datan
                    comp = 'N'
                    trn_output = trn.slice(otime - t1, otime + t2)
                    sac = obspy.io.sac.sactrace.SACTrace.from_obspy_trace(trn_output)
                    sac.stla = coords['latitude']
                    sac.stlo = coords['longitude']
                    sac.stel = coords['elevation']
                    sac.stdp = coords['local_depth']                    
                    sac.cmpaz = 0.
                    sac.cmpinc = 90.
                    sac.kcmpnm = chan+comp
                    sac.evla = evla
                    sac.evlo = evlo
                    sac.evdp = evdp
                    sac.lcalda = True
                    sac.o = t0
                    filename = net+'.'+sta+'.'+chan+comp+'.sac'
                    sac.write('../../'+output_ground_motion+'/'+netchan+'/'+filename)
                    
                    tre = st[2]
                    tre.data = datae
                    comp = 'E'
                    tre_output = tre.slice(otime - t1, otime + t2)
                    sac = obspy.io.sac.sactrace.SACTrace.from_obspy_trace(tre_output)
                    sac.stla = coords['latitude']
                    sac.stlo = coords['longitude']
                    sac.stel = coords['elevation']
                    sac.stdp = coords['local_depth']                    
                    sac.cmpaz = 90.
                    sac.cmpinc = 90.
                    sac.kcmpnm = chan+comp
                    sac.evla = evla
                    sac.evlo = evlo
                    sac.evdp = evdp
                    sac.lcalda = True
                    sac.o = t0
                    filename = net+'.'+sta+'.'+chan+comp+'.sac'
                    sac.write('../../'+output_ground_motion+'/'+netchan+'/'+filename)
                    
                    st_zne = obspy.Stream(traces=[trz_output, trn_output, tre_output])
                    st_gcp_hor = st_zne.rotate(method='NE->RT', back_azimuth=baz)[1:3]
                
                for tr in st_gcp_hor:
                    comp = tr.stats.channel[-1]
                    tr_output = tr.slice(otime - t1, otime + t2)
                    sac = obspy.io.sac.sactrace.SACTrace.from_obspy_trace(tr_output)
                    sac.stla = coords['latitude']
                    sac.stlo = coords['longitude']
                    sac.stel = coords['elevation']
                    sac.stdp = coords['local_depth']
                    if comp == '2':
                        sac.cmpaz = (baz+180.)%360.
                        comp = 'R'
                    if comp == '3':
                        sac.cmpaz = (baz+90.)%360.
                        comp = 'T'
                    sac.cmpinc = 90.
                    sac.kcmpnm = chan+comp
                    sac.evla = evla
                    sac.evlo = evlo
                    sac.evdp = evdp
                    sac.lcalda = True
                    sac.o = t0
                    filename = net+'.'+tr.stats.station+'.'+chan+comp+'.sac'
                    #print('SAC File: ', comp, filename, )
                    sac.write('../../'+output_ground_motion+'/'+netchan+'/'+filename)
                # Add this station to station_list
                station_list.append([net+'.'+chan+'.'+sta, net, chan, sta, coords['latitude'], coords['longitude'], coords['local_depth']] )
                
        print('cwd: ', getcwd())
        chdir('..')
    # End loop over netchan
    # Now do some final things for this event_id: write station files, make map
    chdir('..')
    labels = ['net.chan.sta', 'net', 'chan', 'sta', 'lat', 'lon', 'stdp']
    df_stations = pd.DataFrame.from_records(station_list, columns=labels)
    df_stations.to_csv(event_id+'.station_file', sep=' ')
    f_sw4stations = open(event_id+'.sw4stations', 'w')
   
    for index, row in df_stations.iterrows():
        line = 'rec sta='+row['net']+'.'+row['sta']
        line += ' file='+row['net.chan.sta']
        line += ' lat='+str(row['lat'])
        line += ' lon='+str(row['lon'])
        line += ' depth='+str(row['stdp'])
        line += ' nsew=1 variables=velocity'
        f_sw4stations.writelines(line+'\n')
    f_sw4stations.close()
    
    # Plot map of this event and stations
    min_lon = -123.10
    max_lon = -121.20
    min_lat = 37.20
    max_lat = 38.60
    
    #min_lon = -122.60
    #max_lon = -121.80
    #min_lat = 37.60
    #max_lat = 38.00
    
    plt.figure(figsize=(12,6))
    m = Basemap(projection='merc', lon_0=min_lon, lat_0=max_lat, resolution="i",
                llcrnrlon=min_lon, llcrnrlat=min_lat, urcrnrlon=max_lon, urcrnrlat=max_lat)
    m.drawmapboundary(fill_color='skyblue')
    m.fillcontinents(color='lightgreen',lake_color='skyblue')
    m.drawcoastlines()
#    mt = (np.array([ bsl_mt['m_rr'], bsl_mt['m_tt'], bsl_mt['m_pp'], bsl_mt['m_rt'], bsl_mt['m_rp'], bsl_mt['m_tp'] ])* bsl_mt['m0']).tolist()
    x_ncss, y_ncss = m(ncss_origin['longitude'], ncss_origin['latitude'])
    m.scatter(x_ncss, y_ncss, marker='o', s=100, facecolor='g', edgecolor='k', linewidth=1, zorder=2)
    #x_dd, y_dd = m(dd_origin['longitude'], dd_origin['latitude'])
    x_ev, y_ev = m(ncss_origin['longitude'], ncss_origin['latitude'])
    #m.scatter(x_ev, y_ev, marker='o', s=100, facecolor='r', edgecolor='k', linewidth=1, zorder=2)
    x_sta, y_sta = m(df_stations['lon'].tolist(), df_stations['lat'].tolist())
    sta_name = df_stations['sta'].tolist()
    m.scatter(x_sta, y_sta, marker='^', s=200, facecolor='b', linewidth=1, zorder=10)
    ax = plt.gca()
    for i in range(len(sta_name)):
        ax.text(x_sta[i], y_sta[i], sta_name[i], fontsize=12,fontweight='bold', ha='left',va='bottom',color='k')
    #x_mt, y_mt = m(-121.7, 38.0)
    #x_mt, y_mt = m(dd_origin['longitude'], dd_origin['latitude'])
#    b = beach(mt, xy=(x_ev, y_ev), width=20000, linewidth=1, facecolor='r')
#    b.set_zorder(10)
#    ax.add_collection(b)
    plt.title('Event: '+event_id+' '+otime.strftime("%Y/%m/%d:%H:%M:%S"))
    plt.savefig(event_id+'.map.png')

    # Plot record sections
    #plt.clf()
    #fig, axes = plt.subplots(nrows=3, ncols=1, figsize=(6,12))
    label_time = 120.
    dist_offset = 0.0
    for i, comp in enumerate(['Z', 'R', 'T']):
        print('i, comp: ', i, comp)
        st = obspy.read('VEL/*/*'+comp+'.sac')
        dist_list = []
        stachan_list = []
        for tr in st:
            tr.stats.distance = tr.stats.sac.dist*1000.
            dist_list.append(tr.stats.sac.dist)
            stachan_list.append(tr.stats.station+'.'+tr.stats.channel)
        st.filter(type='bandpass', freqmin=f1, freqmax=f2, corners=2, zerophase=2)
        fig = plt.figure(figsize=(6,12), dpi=300)
        ax = fig.add_subplot(111)
        
        #st.plot(type='section', orientation='horizontal', fig=fig, offset_max=10000)
        st.plot(type='section', orientation='horizontal', fig=fig)
        for i in range(len(st)):
            ax.text(label_time, dist_list[i]+dist_offset, stachan_list[i], fontsize=10, bbox=dict(boxstyle="round", pad=0.0, fc="w"))
        ax.set_title(event_id+' component: '+comp)
        fig.savefig(event_id+'.'+comp+'.recsec.png')

    # Finally after looping over every net_chan, change directory back up for next event
    print('cwd: ', getcwd())
    chdir('..')
# End loop over events
    
